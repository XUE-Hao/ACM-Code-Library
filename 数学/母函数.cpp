///求n可以由1~n的和组成的方案数(每种数无限个)
const int MAXN = 10000+3;///所需要求的和的上限(根据题意修改)
// c1是保存各项质量砝码可以组合的数目
// c2是中间量，保存没一次的情况
int c1[MAXN], c2[MAXN];
int generatingFunction(int x)
{
    int i, j, k;
    for(i=0; i<=x; ++i)   //首先对c1初始化，由第一个表达式(1+x+x^2+..x^n)初始化，把质量从0到n的所有砝码都初始化为1
    {
        c1[i] = 1;
        c2[i] = 0;
    }
    for(i=2; i<=x; ++i)   //i从2到n遍历，这里i就是指第i个表达式，上面给出的第二种母函数关系式里，每一个括号括起来的就是一个表达式
    {
        for(j=0; j<=x; ++j)   //j 从0到n遍历，这里j就是只一个表达式里第j个变量，比如在第二个表达式里：(1+x2^+x^4...)里，第j个就是x^(2*j)
            for(k=0; k+j<=x; k+=i)  //k表示的是第j个指数，所以k每次增i(因为第i个表达式的增量是i)
            {
                c2[j+k] += c1[j];
            }
        for(j=0; j<=x; ++j)     //把c2的值赋给c1,而把c2初始化为0，因为c2每次是从一个表达式中开始的
        {
            c1[j] = c2[j];
            c2[j] = 0;
        }
    }
    return c1[x];
}
